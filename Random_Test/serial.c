#include <stdio.h>
#include <math.h>
#include <string.h>
#include <stdlib.h>
#include "include/externs.h"
#include "include/cephes.h"

extern double Serial_p_Value_1;
extern double Serial_p_Value_2;
extern double Serial_v_Value_1;
extern double Serial_v_Value_2;

double psi2(int m, int n, BitSequence *epsilon);

int Serial(int m, int n, BitSequence *epsilon)
{
    double	p_value1, p_value2, psim0, psim1, psim2, del1, del2;

    psim0 = psi2(m, n, epsilon);
    psim1 = psi2(m - 1, n, epsilon);
    psim2 = psi2(m - 2, n, epsilon);
    del1 = psim0 - psim1;
    del2 = psim0 - 2.0*psim1 + psim2;
    p_value1 = cephes_igamc(pow(2, m-1)/2, del1/2.0);
    p_value2 = cephes_igamc(pow(2, m-2)/2, del2/2.0);

    Serial_v_Value_1=del1;
    Serial_v_Value_2=del2;
    Serial_p_Value_1=p_value1;
    Serial_p_Value_2=p_value2;

//	fprintf(stats[TEST_SERIAL], "\t\t\t       SERIAL TEST\n");
//	fprintf(stats[TEST_SERIAL], "\t\t---------------------------------------------\n");
//	fprintf(stats[TEST_SERIAL], "\t\t COMPUTATIONAL INFORMATION:		  \n");
//	fprintf(stats[TEST_SERIAL], "\t\t---------------------------------------------\n");
//	fprintf(stats[TEST_SERIAL], "\t\t(a) Block length    (m) = %d\n", m);
//	fprintf(stats[TEST_SERIAL], "\t\t(b) Sequence length (n) = %d\n", n);
//	fprintf(stats[TEST_SERIAL], "\t\t(c) Psi_m               = %f\n", psim0);
//	fprintf(stats[TEST_SERIAL], "\t\t(d) Psi_m-1             = %f\n", psim1);
//	fprintf(stats[TEST_SERIAL], "\t\t(e) Psi_m-2             = %f\n", psim2);
//	fprintf(stats[TEST_SERIAL], "\t\t(f) Del_1               = %f\n", del1);
//	fprintf(stats[TEST_SERIAL], "\t\t(g) Del_2               = %f\n", del2);
//	fprintf(stats[TEST_SERIAL], "\t\t---------------------------------------------\n");
//
//	fprintf(stats[TEST_SERIAL], "%s\t\tp_value1 = %f\n", p_value1 < ALPHA ? "FAILURE" : "SUCCESS", p_value1);
//	fprintf(results[TEST_SERIAL], "%f\n", p_value1);

//	fprintf(stats[TEST_SERIAL], "%s\t\tp_value2 = %f\n\n", p_value2 < ALPHA ? "FAILURE" : "SUCCESS", p_value2); fflush(stats[TEST_SERIAL]);
//	fprintf(results[TEST_SERIAL], "%f\n", p_value2); fflush(results[TEST_SERIAL]);
    if (p_value1 < ALPHA || p_value2 < ALPHA) {
        return 0;
    } else {
        return 1;
    }
}

double psi2(int m, int n, BitSequence *epsilon)
{
    int				i, j, k, powLen;
    double			sum, numOfBlocks;
    unsigned int	*P;

    if ( (m == 0) || (m == -1) )
        return 0.0;
    numOfBlocks = n;
    powLen = (int)pow(2, m+1)-1;
    if ( (P = (unsigned int*)calloc(powLen,sizeof(unsigned int)))== NULL ) {
//		fprintf(stats[TEST_SERIAL], "Serial Test:  Insufficient memory available.\n");
//		fflush(stats[TEST_SERIAL]);
        return 0.0;
    }
    for ( i=1; i<powLen-1; i++ )
        P[i] = 0;	  /* INITIALIZE NODES */
    for ( i=0; i<numOfBlocks; i++ ) {		 /* COMPUTE FREQUENCY */
        k = 1;
        for ( j=0; j<m; j++ ) {
            if ( epsilon[(i+j)%n] == 0 )
                k *= 2;
            else if ( epsilon[(i+j)%n] == 1 )
                k = 2*k+1;
        }
        P[k-1]++;
    }
    sum = 0.0;
    for ( i=(int)pow(2, m)-1; i<(int)pow(2, m+1)-1; i++ )
        sum += pow(P[i], 2);
    sum = (sum * pow(2, m)/(double)n) - (double)n;
    free(P);

    return sum;
}
